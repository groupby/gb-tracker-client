const fs = require('fs');
const path = require('path');
const Events = require('../../models/events');
const utils = require('../../utils');
const _ = require('lodash');
const stringify = require('stringify-object');

const distPath = path.join(__dirname, '../');
const schemaPath = `${distPath}/schemas`;

const stringifyOptions = {
  indent: '  ',
  singleQuotes: true
};

const generateFullSchemas = (withSanitization) => (eventType) => {
  const eventClass = capitalizeFirstLetter(eventType);
  const eventName = _.camelCase(eventType);

  console.log(`Building full${withSanitization ? '' : ' validation'} schemas for eventType: ${eventClass}`);

  const schemas = Events[eventClass].getSchemas();

  cleanAndWriteSchemas(schemas, eventName, withSanitization);
};

const generatePartialSchemas = (withSanitization) => (eventType) => {
  const eventClass = capitalizeFirstLetter(eventType);
  const eventName = `auto${eventClass}`;

  console.log(`Building partial${withSanitization ? '' : ' validation'} schemas for eventType: ${eventClass}`);

  const schemas = Events.partials.auto[eventClass].getSchemas();
  cleanAndWriteSchemas(schemas, eventName, withSanitization);
};

const cleanAndWriteSchemas = (schemas, eventName, withSanitization) => {
  // Remove generated validation
  if (eventName !== Events.Invalid.NAME) {
    if (_.has(schemas, 'validation.properties.visit.properties.generated')) {
      delete schemas.validation.properties.visit.properties.generated;
    }

    if (_.has(schemas, 'sanitization.properties.visit.properties.generated')) {
      delete schemas.sanitization.properties.visit.properties.generated;
    }
  }

  // Remove these from the invalid event schemas
  delete schemas.validation.properties.dateReceivedAsInvalid;
  if (_.has(schemas, 'sanitization.properties.dateReceivedAsInvalid')) {
    delete schemas.sanitization.properties.dateReceivedAsInvalid;
  }

  // Do not require ID field on the event from the browser
  delete schemas.validation.properties.id;
  if (_.has(schemas, 'sanitization.properties.id')) {
    delete schemas.sanitization.properties.id;
  }

  const finalSchema = withSanitization ? schemas : { validation: schemas.validation };

  fs.writeFileSync(`${schemaPath}/${eventName}${withSanitization ? '' : '-validate'}.js`, `var utils = require('./utils');${'\n'}module.exports=${stringify(finalSchema, stringifyOptions)}`);
};

const capitalizeFirstLetter = (string) => {
  return string.charAt(0).toUpperCase() + string.slice(1);
};


if (!fs.existsSync(distPath)) {
  fs.mkdirSync(distPath);
}

if (!fs.existsSync(schemaPath)) {
  fs.mkdirSync(schemaPath);
}

// Strip the portions of the schemas that are generated on the backend

const fullEventTypes = [
  'Invalid',
  'AddToCart',
  'ViewCart',
  'RemoveFromCart',
  'Order',
  'Search',
  'SessionChange',
  'ViewProduct'
];

const partialEventTypes = [
  'Search',
  'MoreRefinements'
];

fs.writeFileSync(`${schemaPath}/utils.js`, `module.exports = ${stringify(_.pick(utils, 'regex'), stringifyOptions)};`);
fs.writeFileSync(`${schemaPath}/DO_NOT_TOUCH__ALL_AUTOGENERATED`, `Don't do it.\n\nThese are auto-generated and checked-in by node-common when a release is made.`);

_.forEach(fullEventTypes, generateFullSchemas(true));
_.forEach(fullEventTypes, generateFullSchemas(false));
_.forEach(partialEventTypes, generatePartialSchemas(true));
_.forEach(partialEventTypes, generatePartialSchemas(false));
